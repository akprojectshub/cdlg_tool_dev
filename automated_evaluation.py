from controllers.drift_info_collection import DriftInfo, extract_change_moments_to_list
from controllers.drift_info_collection import NoiseInfo
from controllers.drift_info_collection import LogDriftInfo
from datetime import datetime
from datetime import timedelta
import pm4py

DI_tool = DriftInfo(log_id=1, drift_id=1, process_perspective='control-flow', drift_type='sudden', drift_time=[datetime(2023, 9, 26, 3, 32, 0, 690054)], activities_added=[], activities_deleted=[], activities_moved=["a", "b", "c","d"])
DI_user = DriftInfo(log_id=1, drift_id=1, process_perspective='control-flow', drift_type='sudden', drift_time=[datetime(2023, 9, 26, 3, 32, 0, 690054)], activities_added=[], activities_deleted=[], activities_moved=["a","b", "c"])


#DriftInfo(log_id=2, drift_id=1, process_perspective='control-flow', drift_type='incremental', drift_time=[datetime.datetime(2023, 3, 12, 10, 32, 41, 472162), datetime.datetime(2023, 5, 24, 18, 59, 55, 126128), datetime.datetime(2023, 7, 30, 4, 2, 31, 967276), datetime.datetime(2023, 10, 10, 8, 48, 44, 144540), datetime.datetime(2023, 12, 18, 18, 37, 20, 128335)], activities_added=[], activities_deleted=[j, a, f, e, g], activities_moved=[]]

# "C:/Users/ziedk/OneDrive/Bureau/New folder/cdlg_tool_dev/data/generated_collections/Dummies/Entered by the user"

def drift_time_checker (tool_class,user_class,delta): # I assumed delta is in seconds
    # Path to a gold standard log, path to user generated log
    tool_drift_t = tool_class.drift_time
    user_drift_t =  user_class.drift_time
    # First condition on the drift seasonality number
    if (len(tool_drift_t) != len(user_drift_t)):
        print("Not the same number of seasonal changes considered in the log generated by the tool and the log generated by the user")
    else:
        for i in range(0,len(tool_drift_t)):
            print(abs(timedelta.total_seconds(tool_drift_t[i] - user_drift_t[i])))
            if (abs(timedelta.total_seconds(tool_drift_t[i] - user_drift_t[i])) > delta):
                print("Drift time dicrepancy drift time " + str(i) + " doesn't match the golden standard")
                return False
            else:
                print("Drift time match")
                return True

drift_time_checker(DI_tool,DI_user,0)




def Precision (tool_class, user_class):
    #Precision = TruePositives / (TruePositives + FalsePositives)
    act_aff_tool = list()
    act_aff_tool.extend(tool_class.activities_added)
    act_aff_tool.extend(tool_class.activities_deleted)
    act_aff_tool.extend(tool_class.activities_moved)
    act_aff_tool = set(act_aff_tool)

    act_aff_user = list()
    act_aff_user.extend(user_class.activities_added)
    act_aff_user.extend(user_class.activities_deleted)
    act_aff_user.extend(user_class.activities_moved)
    act_aff_user = set(act_aff_user)

    TP = len(act_aff_tool.intersection(act_aff_user))
    FP = sum([1 for i in act_aff_user if i not in act_aff_tool])
    return TP/ (FP+TP)

def Recall (tool_class, user_class):
    # recall = TruePositives / (TruePositives + FalseNEgatives)
    act_aff_tool = list()
    act_aff_tool.extend(tool_class.activities_added)
    act_aff_tool.extend(tool_class.activities_deleted)
    act_aff_tool.extend(tool_class.activities_moved)
    act_aff_tool = set(act_aff_tool)

    act_aff_user = list()
    act_aff_user.extend(user_class.activities_added)
    act_aff_user.extend(user_class.activities_deleted)
    act_aff_user.extend(user_class.activities_moved)
    act_aff_user = set(act_aff_user)

    TP = len(act_aff_tool.intersection(act_aff_user))
    FN = sum([1 for i in act_aff_tool if i not in act_aff_user])
    return TP / (TP + FN)







x = Precision(DI_tool,DI_user)
print(x)

s = Recall(DI_tool,DI_user)
print(s)

#print(Fitness(DI_tool, DI_user))

from sklearn.metrics import confusion_matrix
import numpy as np


#s = x[0]
#s.append('p')
#print(x[0])

#print(confusion_matrix(np.array(x[0]), np.array(x[1])))


from sklearn.metrics import precision_score

